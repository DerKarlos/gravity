<html>
  <head>
    <title>Gravity Simulation/Game (V4.03)</title>
    <meta http-equiv="Content-Type" content="text/html"; charset="UTF-8">
    <style>	* { margin:0; padding:0; } canvas {id: "canvas" height:100%; width:100% } </style>
    <script type="text/javascript" language="javascript"></script>
  </head>
  <body>
  <canvas id="canvas"></canvas>
  <script> javascript:window.onerror=function(m,u,l){alert(m+"\n"+u+":"+l);}; </script>
  <script>

	  /*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	  Inhalt:               (in Dateien verteilen?)
		Browserabhängiges
	  BEDIENUNG
	  Gravitation
	  SCHIFF
	  Ausgaben	
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

    var browser = navigator.platform;
    console.log('+++ Browser:',browser,' +++ ',new Date(),' +++')

	  var test1=0;
	  var test2=0;
	  var test3=0;
	  var test4=0;

		var dtReal   =    0; // [ms] Reales Zeit-Delta (Wird vom Browser irgendwie vorgegeben)
		var dtLast   =    0; // [ms] Reale Letzte Zeit (zum Errechnen des Deltas)
		var dtSim    =   25; // [ms] Reale minimale Zeitschritte ab der simuliert wird
		var dtMax    =  200; // [ms] Wenn mehr reale Zeit vergangen ist, wird nicht nachgeholt
		var dtFactor =  500; // ???? Die Zeit im Simulator läuft "dtFactor"" mal schneller
		var  aFactor = 2000; // [Picsel/ (km/s2) ] Umrechnung der Beschleunigung zu einem Vektor auf dem Bildschirm
		
		var PointMode = 3 // 0=Rundum-Beschleunigen  1=Bremsen/Beschleunign  3=Neue Masse

		/// Zyklus den der Browsers laufen läßt
    window.requestAnimationFrame(step);
    function step(timestamp) {
			if (!dtLast) dtLast = timestamp; // Erster Zyklus: dt noch 0
			dtReal += (timestamp-dtLast);    // Die reale verstrichene Zeit wurde mehr
			dtLast  =  timestamp;				     // Aktuelle Zeit merken für nächste Delta-Berechenung
			
			if(dtReal>dtMax) dtReal = dtMax; // Große Zeitabschnitte können nicht nachgehholt werden.

      while(dtReal>dtSim)  // Vergangene Zeit wird abgearbeitet
			{ dtReal -=  dtSim;

				/// Hier kommt alles, was im festen Takt zyhlisch laufen soll
	      masses_drag();
		    if(PointMode==0)ShipDrag(); // ää
				ShipInstruments(); // Braucht a-Werte von drag, die bie move wieder gelöscht werden
	      masses_move(dtSim * dtFactor,0);
			}

			/// Hier kommt alles was im Takt des Browserd laufen soll. Meist Ausgaben
			ShipPredictor();
	    gMoveView();
			draw();

	    window.requestAnimationFrame(step); // Nächsten Step beim Browser beauftragen
    }

			 
			 

		function Phytagoras(a,b){ return Math.sqrt( a*a + b*b ); }


		////////////////////// Oben: Browserabhängiges,  BEDIENUNG   ///// Mitte; Gravitation ////// Anten: Ausgaben /////////////////////////////


	  // Maus und Tastatur-Ereignisse abrufen
		this.window.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

		window.addEventListener( 'mousemove',     onMouseMove , false );
		window.addEventListener( 'mousedown',     onMouseDown , false );
		window.addEventListener( 'mouseup',       onMouseUp   , false );
		window.addEventListener( 'mousewheel',    onMouseWheel, false );
		window.addEventListener( 'DOMMouseScroll',onMouseWheel, false ); // firefox
	  window.addEventListener( 'touchstart',    onTouchStart, false );
	  window.addEventListener( 'touchend',      onTouchEnd  , false );
	  window.addEventListener( 'touchmove',     onTouchMove , false );
		//ndow.addEventListener( 'keydown',       onKeyDown   , false );
		//ndow.addEventListener( 'keyup',         onKeyUp     , false );

		var fPoint = false; // First-Pointer aktiv: Erste Maus geklickt, 1-Finger-Touch berührt screen
	  var sPoint = false; // Second
		var tPoint = false; // Third
		var xPoint = 0;  var xPointStart = 0; // Positionen auf dem Bildschrim beim Bedienen
	  var yPoint = 0;  var yPointStart = 0;
		var dPoint = 1;  var dPointStart = 1;
		var dWheel = 0;	 // Bewegung des Mausrads

		//// Maus ////

		function onMouseWheel( event ) {
			event.preventDefault();
			dWheel = 0;
			     if (    event.wheelDelta !== undefined )  // WebKit / Opera / Explorer 9
				dWheel =   event.wheelDelta;
			else if (    event.detail     !== undefined )  // Firefox
				dWheel = - event.detail;
		}


		function onMouseDown( event ) {
			event.preventDefault();  // Verhindere normale Rekation vom Fenster
			event.stopPropagation(); // Stop was?
			// Anfang der Bedienung merken
			xPointStart = xPoint = event.pageX;
		  yPointStart = yPoint = event.pageY;
			// Art der Bedienung merken
			switch ( event.button ) { // 0/1/2=Linke/Mittlere/Rechre-Maustaste
				case 0: fPoint = true; break;
				case 2: sPoint = true; break;
				case 3: tPoint = true; break;
			}
		};


		function onMouseMove( event ) {
	    // Neue Maus-Position merken
			xPoint = event.pageX;
		  yPoint = event.pageY;
		};


		function onMouseUp( event ) {
			event.preventDefault();
			event.stopPropagation();

			switch ( event.button ) {
				case 0: if(PointMode==3) mass_create(3); // Neue Masse nach Drag&Drop erzeugen ää
				        fPoint = false;	break;
				case 2: sPoint = false; break;
				case 3: tPoint = false; break;
			}
		};


	

	  //// Berühren der Touch-Fläche ////

	  function onTouchStart( event ) {  /// Touch START ////////////////////
	    event.preventDefault();
	    event.stopPropagation();
			fPoint = false;  // erst mal alle aus
			sPoint = false;
			tPoint = false;
	    switch ( event.touches.length ) {  // 1/2/3=1/2/3-Finger-Touch
	      case 1: fPoint = true;
								// Anfang der Bedienung merken
	      			  xPointStart = xPoint = event.touches[ 0 ].pageX;
	      				yPointStart = yPoint = event.touches[ 0 ].pageY;
				        break; 
				case 2: sPoint = true;
				        // Anfang der Bedienung merken: Mittelwert aus 1. und 2. Touch
                xPointStart = xPoint = (event.touches[0].pageX+event.touches[1].pageX) / 2;
                yPointStart = yPoint = (event.touches[0].pageY+event.touches[1].pageY) / 2;
								// DeltaPoint: Abstand der beiden Punkte
								dPointStart = dPoint = Phytagoras(
									event.touches[0].pageX-event.touches[1].pageX,
                  event.touches[0].pageY-event.touches[1].pageY)
								break
				case 1: tPoint = true;
								// ...
								break; 
			}
	  }

	  function onTouchMove( event ) {  /// Touch MOVE //////////////////////
	    event.preventDefault();
	    event.stopPropagation();
      xPoint = event.touches[ 0 ].pageX; // Den ersten Touch gibt es immmer
      yPoint = event.touches[ 0 ].pageY;

	    if( event.touches.length >=2 ) {  // Zwei-Punkte-Touch
				// DeltaPoint: neuer Abstand der beiden Punkte
        dPoint = Phytagoras(
					xPoint-event.touches[1].pageX,
					yPoint-event.touches[1].pageY
				);

        // x,y-Mittelwert aus 1. und 2. Touch
        xPoint = (xPoint+event.touches[1].pageX) / 2;
        yPoint = (yPoint+event.touches[1].pageY) / 2;
			}

	  }

    function onTouchEnd  ( event ) {  /// Touch END //////////////////////////
	    event.preventDefault();
	    event.stopPropagation();

			if(PointMode==3) if(fPoint)  mass_create(3); //ää

			fPoint = false;  // alle aus
			sPoint = false;
			tPoint = false;

    }



	  ////////////////////////////////////////////////////////////////////
	  // Drücken der Keyboard-Tasten ergeben Bewegungen            ///////

		function onKeyDown ( event ) {  /// Key DOWN ////////////////
			switch( event.keyCode ) {
				case 38: /*up   */ case 87: /*W*/ this.moveForward  = true; break;
				case 37: /*left */ case 65: /*A*/ this.moveLeft     = true; break;
				case 40: /*down */ case 83: /*S*/ this.moveBackward = true; break;
				case 39: /*right*/ case 68: /*D*/ this.moveRight    = true; break;
				case                    82: /*R*/ this.moveUp       = true; break;
				case                    70: /*F*/ this.moveDown     = true; break;
				case                    81: /*Q*/ this.freeze       = !this.freeze; break;
			}
		};

		function onKeyUp ( event ) {  /// KEy UP  ///////////////////
			switch( event.keyCode ) {
				case 38: /*up   */ case 87: /*W*/ this.moveForward  = false; break;
				case 37: /*left */ case 65: /*A*/ this.moveLeft     = false; break;
				case 40: /*down */ case 83: /*S*/ this.moveBackward = false; break;
				case 39: /*right*/ case 68: /*D*/ this.moveRight    = false; break;
				case                    82: /*R*/ this.moveUp       = false; break;
				case                    70: /*F*/ this.moveDown     = false; break;
			}
		};



		////////////////////// Oben: Browserabhängiges,  BEDIENUNG   ///// Mitte; Gravitation ////// Anten: Ausgaben /////////////////////////////


    // Das Modell enthält nur "echte" Maße und Angaben.


		var dSun = 1.3914e6; //  Sonnen-Durchmesser in km
		var dEar = 12756.32; //     Erd-Durchmesser in km
		var dJup = 142984.0; // Jupiter-Durchmesser in km
		var dLun =   3476.0; //    Luna-Durchmesser in km

		var mSun = 1.989e30; //  Sonnen-Masse in kg
		var mEar = 5.974e24; //     Erd-Masse in kg
		var mJup = 1.899e27; // Jupiter-Masse in kg
		var mLun = 7.349e22; //    Luna-Masse in kg

		var g    = 6.67384e-11  // Gravitationskonstante    m^3/(kg*^2)

		var kmAE = 149597870.700  // km pro Astronomische Einheit   ~1e9
		var  mAE = 149597870700   //  m pro Astronomische Einheit   ~1e12

		var aKey      = 1e-7;     // Triebwerksleistung
		var aShip = 0;

		var sTag  = 60*60*24;    // Sekunden pro Tag  ~10000    1e4
		var sJahr = sTag*364.25; // Sekunden pro Jahr ~4000'000 4e6


		var masses = new Array();
		var ship   = null; // Steuerbarer "Satellit" und sein Perigäum und Perigäum
		var target = null; // Ziel im Spiel zu dem der Pfeil zeigt
		var apo_px=1e9; var apo_py=0; var per_px=1e9; var per_py=0; var ship_a=0; var ship_ax=0; var ship_ay=0;
		
		var aLast = 0; var bLast = 0; // 'Gäumsmerker
		

/** /
		// Sonne, Erde, Luna - Echte Maßstäbe, kaum zu sehen
    var sun   = new Mass("sun"  ,'ffff00',dSun   ,mSun  ,   0,           0,   0, 0        );
    var earth = new Mass("earth",'ff00ff',dEar   ,mEar  ,   0,          -1,   0, 0, sun   );
    var moon  = new Mass("moon" ,'00ffff',dLun   ,mLun  ,   0,-384400/kmAE,   0, 0, earth );
/** /
		// Stern, Planet, Mond - schön groß sichtbar. Geht nur, wenn die Massen nicht zu groß sind!
    var sun   = new Mass("sun"  ,'ffff00',dEar*3 ,mEar*3,   0,           0,   0, 0        );
    var earth = new Mass("earth",'ff00ff',dEar   ,mEar  ,   0,          -1,   0, 0, sun   );
  	var moon  = new Mass("moon" ,'00ffff',dLun   ,mLun  ,   0,        -0.1,   0, 0, earth );
		dtFactor = 100000
		 aFactor = 5000000
/**/
    var sun   = new Mass("sun"  ,'ffff00',dSun   ,mSun   ,   0,           0,   0, 0        );
    var earth = new Mass("earth",'ff00ff',dEar   ,mSun/99,   0,          -1,   0, 0, sun   );
                new Mass("meteo",'00ffff',dEar   ,mSun/99,   0,           1,   0.00000005, 0, sun   );
		dtFactor = 3000
		 aFactor = 3000
		 target  = sun;
/** /
  	var sun  = new Mass("sun" ,'ffff00',dEar   ,mSun	  ,   0,          2,   0, 0  );
  	var shi  = new Mass("shi" ,'00ffff',dEar   ,mEar	  ,   0,          0,   0, 0  );
/**/




		// Jede Masse zieht jede andere an
		function masses_drag() {
		  var aMax= 0;
		  for (iMasse in masses)  // Jede Masse ..
			for (iDragger in masses) { // .. zieht jede andre an
			  a = masses[iMasse].dragged(masses[iDragger]);
			  if(aMax<a) aMax=a;
			  }
		  return aMax
		}
		

		// Jede Masse wird bewegt
		function masses_move(dt,pre) {
		  for (iMasse in masses) masses[iMasse].move(dt,pre);
		  // Hier wird festgelegt, wie lang der "Schweif" Track der Massen ist.
		  // Die könnte über Bedienung variabel sein.
		  // Aber wie berechnet man einen guten Defaultwert??? Der kann sogar bei jeder Masse anders sein (z.B. Mond<>Erde).
		  /// trackSub++; if(trackSub>90) trackSub=0;
		};


    function draw() {
			gDrawPlane();
			mass_create(2); // ää
	    if(ship!=null) {
	      if(ship.o!=null) {
	        gDrawMass(apo_px+ship.o.px,apo_py+ship.o.py,4,'ff0000');
	        gDrawMass(per_px+ship.o.px,per_py+ship.o.py,4,'ff0000');
	      }
	    }

			for (iMasse in masses) {
		    gDrawCurve(
					masses[iMasse].xLine,
					masses[iMasse].yLine,'777777');
				masses[iMasse].draw();			
				} 


      gDrawLine(ship.px, ship.py, // Anzeige des Beshleunigungs-Vektors
				        ship.px+ship_ax*kmAE*aFactor,
       					ship.py+ship_ay*kmAE*aFactor, 'ffffff');

			gDrawLine(ship.px, ship.py, // Anzeige des Geschwindigkeits-Vektors
								ship.px+ship.vx*300000,
					      ship.py+ship.vy*300000, 'aaaaaa');
	
			if(target){
				// macht aus AE einen Faktor 1 und kleiner 1
				var x = -ship.px+target.px;
				var y = -ship.py+target.py;
				var d = Phytagoras(x,y);
				if( Math.abs(x) > Math.abs(y) )
					   { var xx = 1; var yy = Math.abs(y/x); }
				else { var yy = 1; var xx = Math.abs(x/y); }
				if(x<0) xx = -xx; // Richtiges Vorzeichen wieder herstellen
				if(y<0) yy = -yy;

			  var s = 0.1;
				var l = 0.3; if(l > d/100) l = d/100;
				var e = s+l+0.1;
			  gDrawLine(  ship.px+xx*s,   ship.py+yy*s,
             				ship.px+xx*e,   ship.py+yy*e, '008800');
			}
	
			gDrawCurve(xShipLine,yShipLine,'ff0000');


			gDrawText(20, 20,"width/height: "+width+"/"+height+"  dt: "+Math.floor(dtReal/10)+"n");  // 
			gDrawText(20, 40,"Ship x/y vx/vy: " + Math.floor(ship.px*1000)
			                              + "/" + Math.floor(ship.py*1000)
			                              + " " + Math.floor(ship.vx*1000000000)
			                              + "/" + Math.floor(ship.vy*1000000000));
			if(test1!=0) gDrawText(20, 60,"Test1: "+           test1           );
			if(test2!=0) gDrawText(20, 80,"Test2: "+Math.floor(test2*1000)/1000);
			if(test3!=0) gDrawText(20,100,"Test3: "+test3);
			if(test4!=0) gDrawText(20,120,"Test4: "+test4);
    }


		// Geschwindigkeit für eine kreisförmige Umlaufbahn berechnen (keine Methode, da beim Konstruktor noch nicht da
		function mass_vOrbit(m,o) { /* masse,other */
		with (m) {
			var si  = py>0 ? +1 : -1;
		      // Positon und Geschwindigkeit der neuen Masse ist relativ zur umkreisten Masse
				  px += o.px;  vx += o.vx;
				  py += o.py;  vy += o.vy;
			var r   = Phytagoras(  o.px-px
								          ,  o.py-py);           // Radius/Abstand, Masse zur anderen Masse
		      // console.log(o.px,px,o.py,py,r,'x,x,y,y,r')
				  // Für Kreisbahn notwendige Geschwindigkeit errechnen
				  r   = r * mAE;
			var mpm = mass + o.mass;
			var v   = Math.sqrt(2*g*mpm/r);  // wikipedia: Fluchtgeschwindigkeit - Zweite kosmische Geschwindigkeit, 
				  // Geschwindigkeit entsprechend der Massen verteilen
				  v   = v / mAE;  // Aus m/s^2 werden AE/s^2
					  vx += +v / mpm * o.mass * -si; // Eigene v für Orbit
  	      o.vx += -v / mpm *   mass * -si; // Andere v für Orbit
		      // console.log(m,o,r,mpm,v,vx,o.vx,'(m,o,r,mpm,v,vx,o.vx)')
		  }
		}


		///////////////////////////////////////////////////////////////////////////////
		////// Klasse: Masse //////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////

		//// km Klasse: Mass (Masse) ////
		function Mass(name,color,d,m,px,py,vx,vy,o)
		{
		  console.log('mass: (name,color,d,m,px,py,vx,vy,o) ',name,color,d,m,px,py,vx,vy,o)
		  this.name             = name;
		  this.mass             = Math.abs(m);
		  this.px = px; this.vx = vx; this.ax = 0; this.spx = 0; this.svx = 0;
		  this.py = py; this.vy = vy; this.ay = 0; this.spy = 0; this.svy = 0;
		  if(d==0)            d = this.mass/mSun*dSun; // Wenn Durchmesser nicht vorgegeben aus Durchmesser berechnen: / Sonnen-Masse hoch 2
			this.d                = Math.abs(d); // in km
			this.c                = color;
		  this.orbit            = 0; // ggf. Radius des Orbits
			this.xLine = new Array(22);
			this.yLine = new Array(22);
			
      for(var i=0 ; i<this.xLine.length ; i++	) {  // alle Punkte der Linie auf Masse
	      this.xLine[i] = px; this.yLine[i] = py; }
			
		  //r  material = new THREE.MeshLambertMaterial({color: color});
		  //r  geometry = new THREE.SphereGeometry(dd,11,11);
		  //is.mesh     = new THREE.Mesh(geometry,material);
		  //scene.add(this.mesh); 
			masses.push(this);

		  // Umkreist andere Masse? Kreis-Umlaufbahn-Geschwindigkeit-s-Berechnung
		  this.o = null;
		  if (o) {
		    this.o = o;
		    mass_vOrbit(this,o);  	// console.log('o: ',o,this.vy);
	      this.orbit = Math.abs(py); // Masse>0 ? Orbit merken zum anzeigen
		  }

      ship = this;			
    ////end constructor of Mass

		//// Gravitation einer anderen Masse bei DIESER Ausüben
		this.dragged = function(oo) { with(this) {
				// console.log(name,' gezogen von ',  oo.name,oo.mass>0,oo!=this,d!=1);
        var a = 0;
		    if( (oo!=this)      // Sich selbst zieht man nicht an
		      &&(oo.mass>0)     // Anziehender hat Masse (kein Schiff)
		      &&(d!=1)          // Kein Instrument
		       ) { // drag              						//                 Maßeinheit
		      var x = (oo.px-px) * mAE;	                        //        m aus AE
		      var y = (oo.py-py) * mAE;	                        //        m aus AE
		      var p = Phytagoras(x,y);   						// Vektorisiert   m
		      if( p < pgMax ) {	    							//								Schummel: über diesem Abstand keine Ravitaton
		          x = x / p;            						// x-Anteil       0-1
		          y = y / p;            						// y              0-1
		          a = oo.mass / (p*p) * g * 2/*???*/;		// GRAVITATION    kg/m² * m^3/(kg*s²) =Beschleunigung. wikipedia: Newtonsche_Gravitationstheorie: Die Anziehung nimmt im Quadrat der Entfernung ab
		          ax += ((a*x) / mAE);        					//                m/s²  *  1   -> AE/s²
		          ay += ((a*y) / mAE);        					//   anderes Object anziehen (Anteilsmäßig für x und y)
		          //console.log(name,' ',oo.name,a)//(x,y,p,a,ax,ay)
		      }
		    }
		    return a;
		  }}


		// !!! Jegliche Masse darf erst bewegt werden, wenn ALLE drags errechnet sind!

		//// Neue Position und Geschwindigkeit der Masse aus der Beschleunigung für das Zeitdelta errechenn.
		this.move = function(dt,pre) { with(this) {
			vx += ax*dt;  ax=0;  px += vx*dt;
		  vy += ay*dt;  ay=0;  py += vy*dt;
			if(pre<1) {
 	 			xLine.shift(); xLine.push(px);
 	 			yLine.shift(); yLine.push(py);
			}			
		}}

		//// Masse in Welt positionieren
		this.draw = function() { with (this) {
	      if(o) gDrawOrbit( o.px, o.py,orbit);
              gDrawMass(    px,   py,d,c);
		}}

	  //// Sichern/Wiederherstellen von p&v
	  this.save = function(sav) { with (this) {
	      if(sav) {  spx =  px; svx =  vx;
	                 spy =  py; svy =  vy; }
	      else    {   px = spx;  vx = svx; ax=0 //???a weg
	                  py = spy;  vy = svy; ay=0}
	  }}

		
			
		} //end of Mass


    ///// SHIP /////////////////////////////////////////
		var xShipLine = new Array(16);
		var yShipLine = new Array(16);

		// In drag einbauen?
		function ShipInstruments() {  // Muss zwischen Drag und Move sein!
			ship_ax = ship.ax;    // Wert des g-Einflussvektors zur Darstellung
      ship_ay = ship.ay;
		  if(ship.o!=null) {
		    var a = Phytagoras(ship.ax-ship.o.ax,	// Abstand zum umkreisten
					                 ship.ay-ship.o.ay); ship_a = a;
				var b = a-aLast;											// Abstandsänderung
		    // Wenn die Änderung das Vorzeichen gewechselt hat (beide Richtungen):
				if((b<0) && !(bLast<0)) {apo_px = ship.px-ship.o.px; apo_py = ship.py-ship.o.py;}
		    if((b>0) && !(bLast>0)) {per_px = ship.px-ship.o.px; per_py = ship.py-ship.o.py;}
		    aLast = a; bLast = b;
				
		  }
		}
		
		function ShipPredictor() {    // Prediktor: save drag&move restore
			for (iMasse in masses) masses[iMasse].save(1);

      for(var k=0 ; k<xShipLine.length ; k++	)  { // alle Punkte der Linie berechnen
	    //for (var su=0 ; su<(0.01/dt) ; su++) {  // Nur jedes xte mal merken/zeichnen
	      for (var su=0 ; su<(6) ; su++) {  // Nur jedes xte mal merken/zeichnen
          masses_drag(); // Jede Masse zieht jede andere an
	        masses_move(dtSim * dtFactor,1); // Alle Massen bewegen, prediktion!
        }
	      // Linienpunkt auf die Position der Letzten Masse/von sat setzen
	      xShipLine[k] = ship.px;
	      yShipLine[k] = ship.py;
	     }
	    for (iMasse in masses) masses[iMasse].save(0);
		}

		function ShipDrag() {
			// Der Anrieb geht mit einer Rampe auf volle/Null-Leistung
			var aa = 0.05;
			if(fPoint) { aShip += aa; if(aShip>1) aShip=1; }
			else       { aShip -= aa; if(aShip<0) aShip=0; }

			var x = xPoint-xMid;
			var y = yPoint-yMid;

			// macht aus Pixel einen Faktor 1 und kleiner 1
			if( Math.abs(x) > Math.abs(y) )
				   { var ax = 1; var ay = Math.abs(y/x); }
			else { var ay = 1; var ax = Math.abs(x/y); }
			if(x<0) ax = -ax; // Richtiges Vorzeichen wieder herstellen
			if(y<0) ay = -ay;

			// Antriebsleistung in angezeigte Richtung "über Rampe" de/aktivieren
			var a = 5e-13;
			ship.ax += a * ax * aShip;
			ship.ay += a * ay * aShip; 
		}

		function mass_create(ame) { // ää
			switch (ame) {
			case 1: // Anfang
			case 2: // Move
				if(fPoint)
				gDrawLine(
					(xPointStart-xMid)/pixel*zView,
				  (yPointStart-yMid)/pixel*zView,
					(xPoint     -xMid)/pixel*zView,
				  (yPoint     -yMid)/pixel*zView,
					'ffff00');     				               break;
			case 3: // Ende
				var fa=0.000001;
				if(
					Phytagoras(
						xPoint-xPointStart,
						yPoint-yPointStart) > 1
				)
				ship = new Mass("new", 'ffff00', 2, 0, // Minimaler Durchmesser=>Masse
					(xPointStart-xMid)/pixel*zView,
					(yPointStart-yMid)/pixel*zView,
				  (xPoint-xPointStart)/pixel*fa,
				  (yPoint-yPointStart)/pixel*fa);				break;

			} // case

		}






		////////////////////// Oben: Browserabhängiges ///// Mitte; Gravitation ////// Unten: AUSGABEN (Präfix g wie Grafik)

    // Die Ausgabe rechnet die "echten" Werte in Bildpunkte um (Zeit wird hier nicht behandelt)

		// Zeichenfläche und Größe
		var factor = 1; // immer ??? https://github.com/jondavidjohn/hidpi-canvas-polyfill
		var width, height, xMid, yMid, pixel, pixelMax;
		
    var canvas        = document.getElementById('canvas');    // if (!canvas || !canvas.getContext) console.log('!canvas || !canvas.getContext')
    var ctx = canvas.getContext("2d");                        // if (!ctx) console.log('!ctx')   
    		ctx.scale(factor, factor);
		    resizeCanvas();

	  window.addEventListener('resize', resizeCanvas, false);
	  function resizeCanvas() {
  		canvas.width  = window.innerWidth;	// Zeichenfläche = ganze Bildschirmfläche
    	canvas.height = window.innerHeight;
			width  = ctx.canvas.width /factor;  // Die virtuelle Zeichenfläche kann genauer als die Echte sein
			height = ctx.canvas.height/factor;  // Dafür kann die Auflösung des Bildschrims besser sein als der Browser meint.
			xMid  = width /2; 									// Mitte der Zeichenfläche
			yMid  = height/2;
			pixel    = Math.min(xMid,yMid);  			// Die kleinere Ausdehnung zählt als normaler darstellbar Bildpunktebereich
			pixelMax = Math.max(xMid,yMid);  			// Die kleinere Ausdehnung zählt als maximaler darstellbar Bereich
	  }

		// Diese Werte sind Kompromisse zur Visualisierung. Bedienbar?
		var pgMax     = 1e38;   // Über diesem Abstand [AE] keine Gravitaton
		var dMin      = 5;      // Mindestgröße [Pixsel], sonst währen die kleinen Planeten aus der Entfernung nicht sichtbar
		var dMax      = 100;    // Maximalgröße [Pixsel], sonst währen die Sonnen größer als die Umlaufbahnen
		var dFact     = 2000000; // x mal größer, sonst währen die Massen alle gleich klein/groß
		
		// Ausschnitt/Sichtpunkt des virtuellen Uninversums zur darstellung auf dem Bildschirm in AE
		var xView=0;    var xViewStart=0;
		var yView=0;    var yViewStart=0;
		var zView=1.55; var zViewStart=0;

		var xGrid=0;
		var yGrid=0;
		var zGrid=zView*3;


		function gDrawPlane() {
      ctx.fillStyle = "darkgreen";
      ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);

			// Es wird nicht das ganze Universum mit Strichen versehen, nur (ausreichend mehr) der sichtbare Teil 

			// Wenn dir Blickpunkt näher/weiter ist, wird auch der Rasterabstand angepaßt/halbiert/verdoppelt
			if(zGrid>zView*6) zGrid/=2;			
			if(zGrid<zView*3) zGrid*=2;
			var sGrid = zGrid/16;  // +/- x Linien, davon ca 1/3 sichbar
			// Wenn der Blickpunkt verschoben wird, wird auch das Raster verschoben, in Schritten
			if(xGrid > xView+sGrid) xGrid-=sGrid;
			if(xGrid < xView-sGrid) xGrid+=sGrid;
			if(yGrid > yView+sGrid) yGrid-=sGrid;
			if(yGrid < yView-sGrid) yGrid+=sGrid;

			for( var i=-zGrid ; i<=zGrid ; i+=sGrid )
			{ gDrawLine(  i-xGrid, -zGrid-yGrid,  i-xGrid, +zGrid-yGrid,           '007000')
  	    gDrawLine(           -zGrid-xGrid,  i-yGrid, +zGrid-xGrid,  i-yGrid, '007000') }

			/* So schiebt sich der Blickpunkt immer über das Schiff öö */
			if(PointMode==0) {
				xView = -ship.px;
				yView = -ship.py;
			}
			// zView*=1.0001; //??? Langsammes zurückweichen TEST

         gDrawMass(0,0,15,'aaaaaa')
      // gDrawDot(xMid,yMid,50,'aaaaaa')
	    // gDrawLine(0,0,200,400,'aaaaaa')
    }

		function gX(x) { return xMid + (x+xView)/zView*pixel; }
		function gY(y) { return yMid + (y+yView)/zView*pixel; }

    function gMoveView(){
    	if(!sPoint) {
				// Anfang der Verschiebung merken
    		xViewStart = xView;
    		yViewStart = yView;
	  		zViewStart = zView;
    	} else {
    		// Verschieben der Welt
				var f = 0.0025 * zView;  // 0.0025 währe etwa 1:1 aber es darf ruhig schneller gehen. Wie versteckt man die Maus???
				var x =(xPoint+xPoint)/2
				var y =(yPoint+yPoint)/2
				xView = xViewStart + (x-xPointStart) * f;
				yView = yViewStart + (y-yPointStart) * f;
				zView = zViewStart * dPointStart/dPoint;
    	}
			
    	var dz = Math.pow(1.03,Math.abs(dWheel)); // Zoom-Faktor pro weel-zahn
			if ( dWheel > 0 ) zView/=dz;
			else              zView*=dz;
			dWheel = 0;
			
			if(fPoint) test1++;
    }


    function gDrawOrbit(x,y,r) { //
      ctx.strokeStyle = '#999999';
	    ctx.lineWidth   = 1;
      ctx.beginPath();
      ctx.arc (gX(x), gY(y), r/zView*pixel, 0, Math.PI*2)
      ctx.closePath();
      ctx.stroke();
    }

    function gDrawMass(x,y,d,c) {
			
		  var  dd  = d/kmAE         // Meter in Darstellungs-Einheit umrechen
			     dd *= dFact/zView;   // Je weiter wech, desto kleiner
					 dd  = Math.sqrt(dd); // Schummel, damit die Unterschiede nicht so riesig sind
  		  if(dd<dMin) dd=dMin;		// Damit die Masse garantiert immer sichtbar ist
  			if(dd>dMax) dd=dMax;    // Damit die Sonnen nicht alles "überstrahlen""

      ctx.fillStyle = '#'+c;
      ctx.beginPath();
      ctx.arc (gX(x), gY(y), dd/2, 0, Math.PI*2)
      ctx.closePath();
      ctx.fill();
    }

    function gDrawDot(x,y,d,c) {
      ctx.fillStyle = '#'+c;
      ctx.beginPath();
      ctx.arc (x,y, d/2, 0, Math.PI*2)
      ctx.closePath();
      ctx.fill();
    }

    function gDrawLine(xa,ya,xe,ye,c) {
      ctx.lineWidth   = 3;
      ctx.strokeStyle = '#'+c;
      ctx.beginPath();
	    ctx.moveTo( gX(xa), gY(ya) );
	    ctx.lineTo( gX(xe), gY(ye) );
	    ctx.stroke();
      ctx.closePath();
    }

    function gDrawCurve(x,y,c) {
      ctx.lineWidth   = 1;
      ctx.strokeStyle = '#'+c;
      ctx.beginPath();
	    ctx.moveTo( gX(x[0]), gY(y[0]) );

      for(var k=1 ; k<x.length ; k++	)   // alle Punkte der Linie berechnen
			  ctx.lineTo( gX(x[k]), gY(y[k]) );
	    ctx.stroke();
      ctx.closePath();
    }

    function gDrawText(x,y,text) {
      ctx.font="18px Verdana";
      ctx.fillText(text,x,y); 
    }



  </script>    
  </body>
</html>
